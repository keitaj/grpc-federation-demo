// Code generated by protoc-gen-grpc-federation. DO NOT EDIT!
// versions:
//
//	protoc-gen-grpc-federation: v1.21.5
//
// source: proto/bff/bff.proto
package bff

import (
	"context"
	"io"
	"log/slog"
	"reflect"

	grpcfed "github.com/mercari/grpc-federation/grpc/federation"
	grpcfedcel "github.com/mercari/grpc-federation/grpc/federation/cel"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/trace"

	backend "github.com/keitaj/grpc-federation-demo/proto/backend"
)

var (
	_ = reflect.Invalid // to avoid "imported and not used error"
)

var UserViolationType_attrMap = grpcfed.EnumAttributeMap[UserViolationType]{
	UserViolationType_USER_VIOLATION_TYPE_UNSPECIFIED: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `エラーが発生しました。時間をおいて再度お試しください。`,
	},
	UserViolationType_USER_VIOLATION_TYPE_USER_NOT_FOUND: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `ユーザーが見つかりません。ユーザーIDをご確認ください。`,
	},
	UserViolationType_USER_VIOLATION_TYPE_ACCOUNT_SUSPENDED: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `このアカウントは停止されています。`,
	},
}

var OrderViolationType_attrMap = grpcfed.EnumAttributeMap[OrderViolationType]{
	OrderViolationType_ORDER_VIOLATION_TYPE_UNSPECIFIED: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `エラーが発生しました。時間をおいて再度お試しください。`,
	},
	OrderViolationType_ORDER_VIOLATION_TYPE_ORDER_NOT_FOUND: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `注文が見つかりません。注文IDをご確認ください。`,
	},
	OrderViolationType_ORDER_VIOLATION_TYPE_ORDER_CANCELLED: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `この注文はキャンセルされているため、詳細を表示できません。`,
	},
	OrderViolationType_ORDER_VIOLATION_TYPE_NO_ITEMS: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `この注文には商品が含まれていません。`,
	},
}

var ProductViolationType_attrMap = grpcfed.EnumAttributeMap[ProductViolationType]{
	ProductViolationType_PRODUCT_VIOLATION_TYPE_UNSPECIFIED: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `エラーが発生しました。時間をおいて再度お試しください。`,
	},
	ProductViolationType_PRODUCT_VIOLATION_TYPE_PRODUCT_NOT_FOUND: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `商品が見つかりません。商品IDをご確認ください。`,
	},
	ProductViolationType_PRODUCT_VIOLATION_TYPE_PRODUCT_OUT_OF_STOCK: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `この商品は在庫切れです。`,
	},
}

var UserErrorReason_attrMap = grpcfed.EnumAttributeMap[UserErrorReason]{
	UserErrorReason_USER_ERROR_REASON_UNSPECIFIED: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `エラーが発生しました。時間をおいて再度お試しください。`,
	},
	UserErrorReason_USER_ERROR_REASON_MAINTENANCE: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `システムメンテナンス中のため、ユーザーサービスをご利用いただけません。メンテナンス終了後に再度お試しください。`,
	},
	UserErrorReason_USER_ERROR_REASON_UNEXPECTED_ERROR: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `ユーザーサービスでシステムエラーが発生しました。しばらくしてから再度お試しください。`,
	},
}

var OrderErrorReason_attrMap = grpcfed.EnumAttributeMap[OrderErrorReason]{
	OrderErrorReason_ORDER_ERROR_REASON_UNSPECIFIED: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `エラーが発生しました。時間をおいて再度お試しください。`,
	},
	OrderErrorReason_ORDER_ERROR_REASON_MAINTENANCE: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `システムメンテナンス中のため、注文サービスをご利用いただけません。メンテナンス終了後に再度お試しください。`,
	},
	OrderErrorReason_ORDER_ERROR_REASON_UNEXPECTED_ERROR: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `注文サービスでシステムエラーが発生しました。しばらくしてから再度お試しください。`,
	},
}

var ProductErrorReason_attrMap = grpcfed.EnumAttributeMap[ProductErrorReason]{
	ProductErrorReason_PRODUCT_ERROR_REASON_UNSPECIFIED: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `エラーが発生しました。時間をおいて再度お試しください。`,
	},
	ProductErrorReason_PRODUCT_ERROR_REASON_MAINTENANCE: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `システムメンテナンス中のため、商品サービスをご利用いただけません。メンテナンス終了後に再度お試しください。`,
	},
	ProductErrorReason_PRODUCT_ERROR_REASON_UNEXPECTED_ERROR: grpcfed.EnumValueAttributeMap{
		`ja-JP`: `商品サービスでシステムエラーが発生しました。しばらくしてから再度お試しください。`,
	},
}

// Bff_GetOrderDetailsResponseVariable represents variable definitions in "bff.GetOrderDetailsResponse".
type BFFService_Bff_GetOrderDetailsResponseVariable struct {
	ErrorReason       OrderErrorReason
	OrderItems        []*backend.OrderItem
	OrderRes          *backend.GetOrderResponse
	ProductDetails    []*ProductDetail
	TheOrder          *backend.Order
	UserErrorReason   UserErrorReason
	UserRes           *backend.GetUserResponse
	UserViolationType UserViolationType
	ViolationType     OrderViolationType
}

// Bff_GetOrderDetailsResponseArgument is argument for "bff.GetOrderDetailsResponse" message.
type BFFService_Bff_GetOrderDetailsResponseArgument struct {
	OrderId string
	BFFService_Bff_GetOrderDetailsResponseVariable
}

// Bff_GetUserDashboardResponseVariable represents variable definitions in "bff.GetUserDashboardResponse".
type BFFService_Bff_GetUserDashboardResponseVariable struct {
	ErrorReason          UserErrorReason
	OrderErrorReason     OrderErrorReason
	OrderViolationType   OrderViolationType
	OrdersRes            *backend.ListOrdersByUserResponse
	ProductErrorReason   ProductErrorReason
	ProductViolationType ProductViolationType
	ProductsRes          *backend.ListProductsResponse
	Stats                *UserStatistics
	TheUser              *backend.User
	UserRes              *backend.GetUserResponse
	ViolationType        UserViolationType
}

// Bff_GetUserDashboardResponseArgument is argument for "bff.GetUserDashboardResponse" message.
type BFFService_Bff_GetUserDashboardResponseArgument struct {
	UserId string
	BFFService_Bff_GetUserDashboardResponseVariable
}

// Bff_GetUserWithOrdersResponseVariable represents variable definitions in "bff.GetUserWithOrdersResponse".
type BFFService_Bff_GetUserWithOrdersResponseVariable struct {
	ErrorReason        UserErrorReason
	OrderErrorReason   OrderErrorReason
	OrderViolationType OrderViolationType
	OrdersRes          *backend.ListOrdersByUserResponse
	UserRes            *backend.GetUserResponse
	ViolationType      UserViolationType
}

// Bff_GetUserWithOrdersResponseArgument is argument for "bff.GetUserWithOrdersResponse" message.
type BFFService_Bff_GetUserWithOrdersResponseArgument struct {
	UserId string
	BFFService_Bff_GetUserWithOrdersResponseVariable
}

// Bff_ProductDetailVariable represents variable definitions in "bff.ProductDetail".
type BFFService_Bff_ProductDetailVariable struct {
	ErrorReason          ProductErrorReason
	ProductRes           *backend.GetProductResponse
	ProductViolationType ProductViolationType
}

// Bff_ProductDetailArgument is argument for "bff.ProductDetail" message.
type BFFService_Bff_ProductDetailArgument struct {
	Item *backend.OrderItem
	BFFService_Bff_ProductDetailVariable
}

// Bff_UserStatisticsVariable represents variable definitions in "bff.UserStatistics".
type BFFService_Bff_UserStatisticsVariable struct {
}

// Bff_UserStatisticsArgument is argument for "bff.UserStatistics" message.
type BFFService_Bff_UserStatisticsArgument struct {
	Orders      []*backend.Order
	TotalOrders int64
	BFFService_Bff_UserStatisticsVariable
}

// BFFServiceConfig configuration required to initialize the service that use GRPC Federation.
type BFFServiceConfig struct {
	// Client provides a factory that creates the gRPC Client needed to invoke methods of the gRPC Service on which the Federation Service depends.
	// If this interface is not provided, an error is returned during initialization.
	Client BFFServiceClientFactory // required
	// ErrorHandler Federation Service often needs to convert errors received from downstream services.
	// If an error occurs during method execution in the Federation Service, this error handler is called and the returned error is treated as a final error.
	ErrorHandler grpcfed.ErrorHandler
	// Logger sets the logger used to output Debug/Info/Error information.
	Logger *slog.Logger
}

// BFFServiceClientFactory provides a factory that creates the gRPC Client needed to invoke methods of the gRPC Service on which the Federation Service depends.
type BFFServiceClientFactory interface {
	// Order_OrderServiceClient create a gRPC Client to be used to call methods in order.OrderService.
	Order_OrderServiceClient(BFFServiceClientConfig) (backend.OrderServiceClient, error)
	// Product_ProductServiceClient create a gRPC Client to be used to call methods in product.ProductService.
	Product_ProductServiceClient(BFFServiceClientConfig) (backend.ProductServiceClient, error)
	// User_UserServiceClient create a gRPC Client to be used to call methods in user.UserService.
	User_UserServiceClient(BFFServiceClientConfig) (backend.UserServiceClient, error)
}

// BFFServiceClientConfig helper to create gRPC client.
// Hints for creating a gRPC Client.
type BFFServiceClientConfig struct {
	// Service FQDN ( `<package-name>.<service-name>` ) of the service on Protocol Buffers.
	Service string
}

// BFFServiceDependentClientSet has a gRPC client for all services on which the federation service depends.
// This is provided as an argument when implementing the custom resolver.
type BFFServiceDependentClientSet struct {
	Order_OrderServiceClient     backend.OrderServiceClient
	Product_ProductServiceClient backend.ProductServiceClient
	User_UserServiceClient       backend.UserServiceClient
}

// BFFServiceResolver provides an interface to directly implement message resolver and field resolver not defined in Protocol Buffers.
type BFFServiceResolver interface {
}

// BFFServiceCELPluginWasmConfig type alias for grpcfedcel.WasmConfig.
type BFFServiceCELPluginWasmConfig = grpcfedcel.WasmConfig

// BFFServiceCELPluginConfig hints for loading a WebAssembly based plugin.
type BFFServiceCELPluginConfig struct {
	CacheDir string
}

// BFFServiceUnimplementedResolver a structure implemented to satisfy the Resolver interface.
// An Unimplemented error is always returned.
// This is intended for use when there are many Resolver interfaces that do not need to be implemented,
// by embedding them in a resolver structure that you have created.
type BFFServiceUnimplementedResolver struct{}

const (
	BFFService_DependentMethod_Order_OrderService_GetOrder         = "/order.OrderService/GetOrder"
	BFFService_DependentMethod_Order_OrderService_ListOrdersByUser = "/order.OrderService/ListOrdersByUser"
	BFFService_DependentMethod_Product_ProductService_GetProduct   = "/product.ProductService/GetProduct"
	BFFService_DependentMethod_Product_ProductService_ListProducts = "/product.ProductService/ListProducts"
	BFFService_DependentMethod_User_UserService_GetUser            = "/user.UserService/GetUser"
)

// BFFService represents Federation Service.
type BFFService struct {
	UnimplementedBFFServiceServer
	cfg           BFFServiceConfig
	logger        *slog.Logger
	errorHandler  grpcfed.ErrorHandler
	celCacheMap   *grpcfed.CELCacheMap
	tracer        trace.Tracer
	celTypeHelper *grpcfed.CELTypeHelper
	celEnvOpts    []grpcfed.CELEnvOption
	celPlugins    []*grpcfedcel.CELPlugin
	client        *BFFServiceDependentClientSet
}

// NewBFFService creates BFFService instance by BFFServiceConfig.
func NewBFFService(cfg BFFServiceConfig) (*BFFService, error) {
	if cfg.Client == nil {
		return nil, grpcfed.ErrClientConfig
	}
	Order_OrderServiceClient, err := cfg.Client.Order_OrderServiceClient(BFFServiceClientConfig{
		Service: "order.OrderService",
	})
	if err != nil {
		return nil, err
	}
	Product_ProductServiceClient, err := cfg.Client.Product_ProductServiceClient(BFFServiceClientConfig{
		Service: "product.ProductService",
	})
	if err != nil {
		return nil, err
	}
	User_UserServiceClient, err := cfg.Client.User_UserServiceClient(BFFServiceClientConfig{
		Service: "user.UserService",
	})
	if err != nil {
		return nil, err
	}
	logger := cfg.Logger
	if logger == nil {
		logger = slog.New(slog.NewJSONHandler(io.Discard, nil))
	}
	errorHandler := cfg.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(ctx context.Context, methodName string, err error) error { return err }
	}
	celTypeHelperFieldMap := grpcfed.CELTypeHelperFieldMap{
		"grpc.federation.private.bff.GetOrderDetailsResponseArgument": {
			"order_id": grpcfed.NewCELFieldType(grpcfed.CELStringType, "OrderId"),
		},
		"grpc.federation.private.bff.GetUserDashboardResponseArgument": {
			"user_id": grpcfed.NewCELFieldType(grpcfed.CELStringType, "UserId"),
		},
		"grpc.federation.private.bff.GetUserWithOrdersResponseArgument": {
			"user_id": grpcfed.NewCELFieldType(grpcfed.CELStringType, "UserId"),
		},
		"grpc.federation.private.bff.ProductDetailArgument": {
			"item": grpcfed.NewCELFieldType(grpcfed.NewCELObjectType("order.OrderItem"), "Item"),
		},
		"grpc.federation.private.bff.UserStatisticsArgument": {
			"total_orders": grpcfed.NewCELFieldType(grpcfed.CELIntType, "TotalOrders"),
			"orders":       grpcfed.NewCELFieldType(grpcfed.NewCELListType(grpcfed.NewCELObjectType("order.Order")), "Orders"),
		},
	}
	celTypeHelper := grpcfed.NewCELTypeHelper("bff", celTypeHelperFieldMap)
	var celEnvOpts []grpcfed.CELEnvOption
	celEnvOpts = append(celEnvOpts, grpcfed.NewDefaultEnvOptions(celTypeHelper)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("bff.OrderErrorReason", OrderErrorReason_value, OrderErrorReason_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAttrOption[OrderErrorReason]("bff.OrderErrorReason", OrderErrorReason_attrMap))
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("bff.OrderViolationType", OrderViolationType_value, OrderViolationType_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAttrOption[OrderViolationType]("bff.OrderViolationType", OrderViolationType_attrMap))
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("bff.ProductErrorReason", ProductErrorReason_value, ProductErrorReason_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAttrOption[ProductErrorReason]("bff.ProductErrorReason", ProductErrorReason_attrMap))
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("bff.ProductViolationType", ProductViolationType_value, ProductViolationType_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAttrOption[ProductViolationType]("bff.ProductViolationType", ProductViolationType_attrMap))
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("bff.UserErrorReason", UserErrorReason_value, UserErrorReason_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAttrOption[UserErrorReason]("bff.UserErrorReason", UserErrorReason_attrMap))
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("bff.UserViolationType", UserViolationType_value, UserViolationType_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAttrOption[UserViolationType]("bff.UserViolationType", UserViolationType_attrMap))
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("order.OrderErrorReason", backend.OrderErrorReason_value, backend.OrderErrorReason_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("order.OrderFailureCode", backend.OrderFailureCode_value, backend.OrderFailureCode_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("order.OrderStatus", backend.OrderStatus_value, backend.OrderStatus_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("product.ProductErrorReason", backend.ProductErrorReason_value, backend.ProductErrorReason_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("product.ProductFailureCode", backend.ProductFailureCode_value, backend.ProductFailureCode_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("user.UserErrorReason", backend.UserErrorReason_value, backend.UserErrorReason_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("user.UserFailureCode", backend.UserFailureCode_value, backend.UserFailureCode_name)...)
	svc := &BFFService{
		cfg:           cfg,
		logger:        logger,
		errorHandler:  errorHandler,
		celEnvOpts:    celEnvOpts,
		celTypeHelper: celTypeHelper,
		celCacheMap:   grpcfed.NewCELCacheMap(),
		tracer:        otel.Tracer("bff.BFFService"),
		client: &BFFServiceDependentClientSet{
			Order_OrderServiceClient:     Order_OrderServiceClient,
			Product_ProductServiceClient: Product_ProductServiceClient,
			User_UserServiceClient:       User_UserServiceClient,
		},
	}
	return svc, nil
}

// CleanupBFFService cleanup all resources to prevent goroutine leaks.
func CleanupBFFService(ctx context.Context, svc *BFFService) {
	svc.cleanup(ctx)
}

func (s *BFFService) cleanup(ctx context.Context) {
	for _, plugin := range s.celPlugins {
		plugin.Close()
	}
}

// GetUserWithOrders implements "bff.BFFService/GetUserWithOrders" method.
func (s *BFFService) GetUserWithOrders(ctx context.Context, req *GetUserWithOrdersRequest) (res *GetUserWithOrdersResponse, e error) {
	ctx, span := s.tracer.Start(ctx, "bff.BFFService/GetUserWithOrders")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, s.logger)
	ctx = grpcfed.WithCELCacheMap(ctx, s.celCacheMap)
	defer func() {
		if r := recover(); r != nil {
			e = grpcfed.RecoverError(r, grpcfed.StackTrace())
			grpcfed.OutputErrorLog(ctx, e)
		}
	}()
	defer func() {
		for _, celPlugin := range s.celPlugins {
			celPlugin.Cleanup()
		}
	}()
	res, err := s.resolve_Bff_GetUserWithOrdersResponse(ctx, &BFFService_Bff_GetUserWithOrdersResponseArgument{
		UserId: req.GetUserId(),
	})
	if err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		grpcfed.OutputErrorLog(ctx, err)
		return nil, err
	}
	return res, nil
}

// GetOrderDetails implements "bff.BFFService/GetOrderDetails" method.
func (s *BFFService) GetOrderDetails(ctx context.Context, req *GetOrderDetailsRequest) (res *GetOrderDetailsResponse, e error) {
	ctx, span := s.tracer.Start(ctx, "bff.BFFService/GetOrderDetails")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, s.logger)
	ctx = grpcfed.WithCELCacheMap(ctx, s.celCacheMap)
	defer func() {
		if r := recover(); r != nil {
			e = grpcfed.RecoverError(r, grpcfed.StackTrace())
			grpcfed.OutputErrorLog(ctx, e)
		}
	}()
	defer func() {
		for _, celPlugin := range s.celPlugins {
			celPlugin.Cleanup()
		}
	}()
	res, err := s.resolve_Bff_GetOrderDetailsResponse(ctx, &BFFService_Bff_GetOrderDetailsResponseArgument{
		OrderId: req.GetOrderId(),
	})
	if err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		grpcfed.OutputErrorLog(ctx, err)
		return nil, err
	}
	return res, nil
}

// GetUserDashboard implements "bff.BFFService/GetUserDashboard" method.
func (s *BFFService) GetUserDashboard(ctx context.Context, req *GetUserDashboardRequest) (res *GetUserDashboardResponse, e error) {
	ctx, span := s.tracer.Start(ctx, "bff.BFFService/GetUserDashboard")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, s.logger)
	ctx = grpcfed.WithCELCacheMap(ctx, s.celCacheMap)
	defer func() {
		if r := recover(); r != nil {
			e = grpcfed.RecoverError(r, grpcfed.StackTrace())
			grpcfed.OutputErrorLog(ctx, e)
		}
	}()
	defer func() {
		for _, celPlugin := range s.celPlugins {
			celPlugin.Cleanup()
		}
	}()
	res, err := s.resolve_Bff_GetUserDashboardResponse(ctx, &BFFService_Bff_GetUserDashboardResponseArgument{
		UserId: req.GetUserId(),
	})
	if err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		grpcfed.OutputErrorLog(ctx, err)
		return nil, err
	}
	return res, nil
}

// resolve_Bff_GetOrderDetailsResponse resolve "bff.GetOrderDetailsResponse" message.
func (s *BFFService) resolve_Bff_GetOrderDetailsResponse(ctx context.Context, req *BFFService_Bff_GetOrderDetailsResponseArgument) (*GetOrderDetailsResponse, error) {
	ctx, span := s.tracer.Start(ctx, "bff.GetOrderDetailsResponse")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve bff.GetOrderDetailsResponse", slog.Any("message_args", s.logvalue_Bff_GetOrderDetailsResponseArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			ErrorReason       OrderErrorReason
			OrderItems        []*backend.OrderItem
			OrderRes          *backend.GetOrderResponse
			ProductDetails    []*ProductDetail
			TheOrder          *backend.Order
			UserErrorReason   UserErrorReason
			UserRes           *backend.GetUserResponse
			UserViolationType UserViolationType
			ViolationType     OrderViolationType
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.bff.GetOrderDetailsResponseArgument", req)}
	/*
		def {
		  name: "order_res"
		  call {
		    method: "order.OrderService/GetOrder"
		    request { field: "order_id", by: "$.order_id" }
		  }
		}
	*/
	def_order_res := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.GetOrderResponse, *localValueType]{
			Name: `order_res`,
			Type: grpcfed.CELObjectType("order.GetOrderResponse"),
			Setter: func(value *localValueType, v *backend.GetOrderResponse) error {
				value.vars.OrderRes = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &backend.GetOrderRequest{}
				// { field: "order_id", by: "$.order_id" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `$.order_id`,
					CacheIndex: 1,
					Setter: func(v string) error {
						args.OrderId = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				grpcfed.Logger(ctx).DebugContext(ctx, "call order.OrderService/GetOrder", slog.Any("order.GetOrderRequest", s.logvalue_Order_GetOrderRequest(args)))
				ret, err := grpcfed.WithTimeout[backend.GetOrderResponse](ctx, "order.OrderService/GetOrder", 5000000000 /* 5s */, func(ctx context.Context) (*backend.GetOrderResponse, error) {
					b := grpcfed.NewExponentialBackOff(&grpcfed.ExponentialBackOffConfig{
						InitialInterval:     250000000, /* 250ms */
						RandomizationFactor: 0.5,
						Multiplier:          1.5,
						MaxInterval:         60000000000, /* 1m0s */
						MaxElapsedTime:      5000000000,  /* 5s */
					})
					b = grpcfed.BackOffWithMaxRetries(b, 1)
					b = grpcfed.BackOffWithContext(b, ctx)
					return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[backend.GetOrderResponse]{
						Value:      value,
						If:         `error.code != google.rpc.Code.FAILED_PRECONDITION && error.code != google.rpc.Code.UNAVAILABLE`,
						CacheIndex: 2,
						BackOff:    b,
						Body: func() (*backend.GetOrderResponse, error) {
							return s.client.Order_OrderServiceClient.GetOrder(ctx, args)
						},
					})
				})
				if err != nil {
					grpcfed.SetGRPCError(ctx, value, err)
					var (
						defaultMsg     string
						defaultCode    grpcfed.Code
						defaultDetails []grpcfed.ProtoMessage
					)
					if stat, exists := grpcfed.GRPCStatusFromError(err); exists {
						defaultMsg = stat.Message()
						defaultCode = stat.Code()
						details := stat.Details()
						defaultDetails = make([]grpcfed.ProtoMessage, 0, len(details))
						for _, detail := range details {
							msg, ok := detail.(grpcfed.ProtoMessage)
							if ok {
								defaultDetails = append(defaultDetails, msg)
							}
						}
						_ = defaultMsg
						_ = defaultCode
						_ = defaultDetails
					}

					type localStatusType struct {
						status   *grpcfed.Status
						logLevel slog.Level
					}
					stat, handleErr := func() (*localStatusType, error) {
						var stat *grpcfed.Status
						{
							/*
								def {
								  name: "violation_type"
								  enum {
								    name: "bff.OrderViolationType"
								    by: "order.OrderFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))"
								  }
								}
							*/
							def_violation_type := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[OrderViolationType, *localValueType]{
									Name: `violation_type`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v OrderViolationType) error {
										value.vars.ViolationType = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (OrderViolationType, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `order.OrderFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))`,
											OutType:    reflect.TypeOf(backend.OrderFailureCode(0)),
											CacheIndex: 3,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.OrderFailureCode)
										return s.cast_Order_OrderFailureCode__to__Bff_OrderViolationType(v)
									},
								})
							}

							if err := def_violation_type(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `violation_type != OrderViolationType.ORDER_VIOLATION_TYPE_UNSPECIFIED`,
								CacheIndex: 4,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 5,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 6,
										Body: func(value *localValueType) error {
											if detail := grpcfed.PreconditionFailure(ctx, value, []*grpcfed.PreconditionFailureViolation{
												{
													Type:              `OrderViolationType.name(violation_type)`,
													Subject:           `'GetOrderDetails'`,
													Desc:              `error.message`,
													TypeCacheIndex:    7,
													SubjectCacheIndex: 8,
													DescCacheIndex:    9,
												},
											}); detail != nil {
												details = append(details, detail)
											}
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `OrderViolationType.attr(violation_type, 'ja-JP')`,
												CacheIndex: 10,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.FailedPreconditionCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						{
							/*
								def {
								  name: "error_reason"
								  enum {
								    name: "bff.OrderErrorReason"
								    by: "order.OrderErrorReason.value(error.error_info[?0].reason.orValue(''))"
								  }
								}
							*/
							def_error_reason := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[OrderErrorReason, *localValueType]{
									Name: `error_reason`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v OrderErrorReason) error {
										value.vars.ErrorReason = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (OrderErrorReason, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `order.OrderErrorReason.value(error.error_info[?0].reason.orValue(''))`,
											OutType:    reflect.TypeOf(backend.OrderErrorReason(0)),
											CacheIndex: 11,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.OrderErrorReason)
										return s.cast_Order_OrderErrorReason__to__Bff_OrderErrorReason(v)
									},
								})
							}

							if err := def_error_reason(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `error.code == google.rpc.Code.UNAVAILABLE`,
								CacheIndex: 12,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 13,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 14,
										Body: func(value *localValueType) error {
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `OrderErrorReason.attr(error_reason, 'ja-JP')`,
												CacheIndex: 15,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.UnavailableCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						return nil, nil
					}()
					if handleErr != nil {
						grpcfed.Logger(ctx).ErrorContext(ctx, "failed to handle error", slog.String("error", handleErr.Error()))
						// If it fails during error handling, return the original error.
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Order_OrderService_GetOrder, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					} else if stat != nil {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Order_OrderService_GetOrder, stat.status.Err()); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, stat.logLevel, grpcfed.LogAttrs(ctx))
						}
					} else {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Order_OrderService_GetOrder, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					}
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "the_order"
		  by: "order_res.order"
		}
	*/
	def_the_order := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.Order, *localValueType]{
			Name: `the_order`,
			Type: grpcfed.CELObjectType("order.Order"),
			Setter: func(value *localValueType, v *backend.Order) error {
				value.vars.TheOrder = v
				return nil
			},
			By:           `order_res.order`,
			ByCacheIndex: 16,
		})
	}

	/*
		def {
		  name: "order_items"
		  by: "the_order.items"
		}
	*/
	def_order_items := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[[]*backend.OrderItem, *localValueType]{
			Name: `order_items`,
			Type: grpcfed.CELListType(grpcfed.CELObjectType("order.OrderItem")),
			Setter: func(value *localValueType, v []*backend.OrderItem) error {
				value.vars.OrderItems = v
				return nil
			},
			By:           `the_order.items`,
			ByCacheIndex: 17,
		})
	}

	/*
		def {
		  name: "user_res"
		  call {
		    method: "user.UserService/GetUser"
		    request { field: "user_id", by: "the_order.user_id" }
		  }
		}
	*/
	def_user_res := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.GetUserResponse, *localValueType]{
			Name: `user_res`,
			Type: grpcfed.CELObjectType("user.GetUserResponse"),
			Setter: func(value *localValueType, v *backend.GetUserResponse) error {
				value.vars.UserRes = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &backend.GetUserRequest{}
				// { field: "user_id", by: "the_order.user_id" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `the_order.user_id`,
					CacheIndex: 18,
					Setter: func(v string) error {
						args.UserId = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				grpcfed.Logger(ctx).DebugContext(ctx, "call user.UserService/GetUser", slog.Any("user.GetUserRequest", s.logvalue_User_GetUserRequest(args)))
				ret, err := grpcfed.WithTimeout[backend.GetUserResponse](ctx, "user.UserService/GetUser", 5000000000 /* 5s */, func(ctx context.Context) (*backend.GetUserResponse, error) {
					b := grpcfed.NewExponentialBackOff(&grpcfed.ExponentialBackOffConfig{
						InitialInterval:     250000000, /* 250ms */
						RandomizationFactor: 0.5,
						Multiplier:          1.5,
						MaxInterval:         60000000000, /* 1m0s */
						MaxElapsedTime:      5000000000,  /* 5s */
					})
					b = grpcfed.BackOffWithMaxRetries(b, 1)
					b = grpcfed.BackOffWithContext(b, ctx)
					return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[backend.GetUserResponse]{
						Value:      value,
						If:         `error.code != google.rpc.Code.FAILED_PRECONDITION && error.code != google.rpc.Code.UNAVAILABLE`,
						CacheIndex: 19,
						BackOff:    b,
						Body: func() (*backend.GetUserResponse, error) {
							return s.client.User_UserServiceClient.GetUser(ctx, args)
						},
					})
				})
				if err != nil {
					grpcfed.SetGRPCError(ctx, value, err)
					var (
						defaultMsg     string
						defaultCode    grpcfed.Code
						defaultDetails []grpcfed.ProtoMessage
					)
					if stat, exists := grpcfed.GRPCStatusFromError(err); exists {
						defaultMsg = stat.Message()
						defaultCode = stat.Code()
						details := stat.Details()
						defaultDetails = make([]grpcfed.ProtoMessage, 0, len(details))
						for _, detail := range details {
							msg, ok := detail.(grpcfed.ProtoMessage)
							if ok {
								defaultDetails = append(defaultDetails, msg)
							}
						}
						_ = defaultMsg
						_ = defaultCode
						_ = defaultDetails
					}

					type localStatusType struct {
						status   *grpcfed.Status
						logLevel slog.Level
					}
					stat, handleErr := func() (*localStatusType, error) {
						var stat *grpcfed.Status
						{
							/*
								def {
								  name: "user_violation_type"
								  enum {
								    name: "bff.UserViolationType"
								    by: "user.UserFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))"
								  }
								}
							*/
							def_user_violation_type := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[UserViolationType, *localValueType]{
									Name: `user_violation_type`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v UserViolationType) error {
										value.vars.UserViolationType = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (UserViolationType, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `user.UserFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))`,
											OutType:    reflect.TypeOf(backend.UserFailureCode(0)),
											CacheIndex: 20,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.UserFailureCode)
										return s.cast_User_UserFailureCode__to__Bff_UserViolationType(v)
									},
								})
							}

							if err := def_user_violation_type(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `user_violation_type != UserViolationType.USER_VIOLATION_TYPE_UNSPECIFIED`,
								CacheIndex: 21,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 22,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 23,
										Body: func(value *localValueType) error {
											if detail := grpcfed.PreconditionFailure(ctx, value, []*grpcfed.PreconditionFailureViolation{
												{
													Type:              `UserViolationType.name(user_violation_type)`,
													Subject:           `'GetOrderDetails'`,
													Desc:              `error.message`,
													TypeCacheIndex:    24,
													SubjectCacheIndex: 25,
													DescCacheIndex:    26,
												},
											}); detail != nil {
												details = append(details, detail)
											}
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `UserViolationType.attr(user_violation_type, 'ja-JP')`,
												CacheIndex: 27,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.FailedPreconditionCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						{
							/*
								def {
								  name: "user_error_reason"
								  enum {
								    name: "bff.UserErrorReason"
								    by: "user.UserErrorReason.value(error.error_info[?0].reason.orValue(''))"
								  }
								}
							*/
							def_user_error_reason := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[UserErrorReason, *localValueType]{
									Name: `user_error_reason`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v UserErrorReason) error {
										value.vars.UserErrorReason = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (UserErrorReason, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `user.UserErrorReason.value(error.error_info[?0].reason.orValue(''))`,
											OutType:    reflect.TypeOf(backend.UserErrorReason(0)),
											CacheIndex: 28,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.UserErrorReason)
										return s.cast_User_UserErrorReason__to__Bff_UserErrorReason(v)
									},
								})
							}

							if err := def_user_error_reason(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `error.code == google.rpc.Code.UNAVAILABLE`,
								CacheIndex: 29,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 30,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 31,
										Body: func(value *localValueType) error {
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `UserErrorReason.attr(user_error_reason, 'ja-JP')`,
												CacheIndex: 32,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.UnavailableCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						return nil, nil
					}()
					if handleErr != nil {
						grpcfed.Logger(ctx).ErrorContext(ctx, "failed to handle error", slog.String("error", handleErr.Error()))
						// If it fails during error handling, return the original error.
						if err := s.errorHandler(ctx, BFFService_DependentMethod_User_UserService_GetUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					} else if stat != nil {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_User_UserService_GetUser, stat.status.Err()); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, stat.logLevel, grpcfed.LogAttrs(ctx))
						}
					} else {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_User_UserService_GetUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					}
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "product_details"
		  map {
		    iterator {
		      name: "item"
		      src: "order_items"
		    }
		    message {
		      name: "ProductDetail"
		      args { name: "item", by: "item" }
		    }
		  }
		}
	*/
	def_product_details := func(ctx context.Context) error {
		return grpcfed.EvalDefMap(ctx, value, grpcfed.DefMap[[]*ProductDetail, *backend.OrderItem, *localValueType]{
			Name: `product_details`,
			Type: grpcfed.CELListType(grpcfed.CELObjectType("bff.ProductDetail")),
			Setter: func(value *localValueType, v []*ProductDetail) error {
				value.vars.ProductDetails = v
				return nil
			},
			IteratorName:   `item`,
			IteratorType:   grpcfed.CELObjectType("order.OrderItem"),
			IteratorSource: func(value *localValueType) []*backend.OrderItem { return value.vars.OrderItems },
			Iterator: func(ctx context.Context, value *grpcfed.MapIteratorValue) (any, error) {
				args := &BFFService_Bff_ProductDetailArgument{}
				// { name: "item", by: "item" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*backend.OrderItem]{
					Value:      value,
					Expr:       `item`,
					CacheIndex: 33,
					Setter: func(v *backend.OrderItem) error {
						args.Item = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				return s.resolve_Bff_ProductDetail(ctx, args)
			},
		})
	}

	// A tree view of message dependencies is shown below.
	/*
	   order_res ─┐
	              the_order ─┐
	                         order_items ─┐
	                                      product_details ─┐
	              order_res ─┐                             │
	                           the_order ─┐                │
	                                             user_res ─┤
	*/
	eg, ctx1 := grpcfed.ErrorGroupWithContext(ctx)

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_order_res(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_the_order(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_order_items(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_product_details(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_order_res(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_the_order(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_user_res(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	if err := eg.Wait(); err != nil {
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.BFFService_Bff_GetOrderDetailsResponseVariable.ErrorReason = value.vars.ErrorReason
	req.BFFService_Bff_GetOrderDetailsResponseVariable.OrderItems = value.vars.OrderItems
	req.BFFService_Bff_GetOrderDetailsResponseVariable.OrderRes = value.vars.OrderRes
	req.BFFService_Bff_GetOrderDetailsResponseVariable.ProductDetails = value.vars.ProductDetails
	req.BFFService_Bff_GetOrderDetailsResponseVariable.TheOrder = value.vars.TheOrder
	req.BFFService_Bff_GetOrderDetailsResponseVariable.UserErrorReason = value.vars.UserErrorReason
	req.BFFService_Bff_GetOrderDetailsResponseVariable.UserRes = value.vars.UserRes
	req.BFFService_Bff_GetOrderDetailsResponseVariable.UserViolationType = value.vars.UserViolationType
	req.BFFService_Bff_GetOrderDetailsResponseVariable.ViolationType = value.vars.ViolationType

	// create a message value to be returned.
	ret := &GetOrderDetailsResponse{}

	// field binding section.
	// (grpc.federation.field).by = "the_order"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*backend.Order]{
		Value:      value,
		Expr:       `the_order`,
		CacheIndex: 34,
		Setter: func(v *backend.Order) error {
			ret.Order = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "user_res.user"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*backend.User]{
		Value:      value,
		Expr:       `user_res.user`,
		CacheIndex: 35,
		Setter: func(v *backend.User) error {
			ret.User = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "product_details"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[[]*ProductDetail]{
		Value:      value,
		Expr:       `product_details`,
		CacheIndex: 36,
		Setter: func(v []*ProductDetail) error {
			ret.ProductDetails = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved bff.GetOrderDetailsResponse", slog.Any("bff.GetOrderDetailsResponse", s.logvalue_Bff_GetOrderDetailsResponse(ret)))
	return ret, nil
}

// resolve_Bff_GetUserDashboardResponse resolve "bff.GetUserDashboardResponse" message.
func (s *BFFService) resolve_Bff_GetUserDashboardResponse(ctx context.Context, req *BFFService_Bff_GetUserDashboardResponseArgument) (*GetUserDashboardResponse, error) {
	ctx, span := s.tracer.Start(ctx, "bff.GetUserDashboardResponse")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve bff.GetUserDashboardResponse", slog.Any("message_args", s.logvalue_Bff_GetUserDashboardResponseArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			ErrorReason          UserErrorReason
			OrderErrorReason     OrderErrorReason
			OrderViolationType   OrderViolationType
			OrdersRes            *backend.ListOrdersByUserResponse
			ProductErrorReason   ProductErrorReason
			ProductViolationType ProductViolationType
			ProductsRes          *backend.ListProductsResponse
			Stats                *UserStatistics
			TheUser              *backend.User
			UserRes              *backend.GetUserResponse
			ViolationType        UserViolationType
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.bff.GetUserDashboardResponseArgument", req)}
	/*
		def {
		  name: "user_res"
		  call {
		    method: "user.UserService/GetUser"
		    request { field: "user_id", by: "$.user_id" }
		  }
		}
	*/
	def_user_res := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.GetUserResponse, *localValueType]{
			Name: `user_res`,
			Type: grpcfed.CELObjectType("user.GetUserResponse"),
			Setter: func(value *localValueType, v *backend.GetUserResponse) error {
				value.vars.UserRes = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &backend.GetUserRequest{}
				// { field: "user_id", by: "$.user_id" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `$.user_id`,
					CacheIndex: 37,
					Setter: func(v string) error {
						args.UserId = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				grpcfed.Logger(ctx).DebugContext(ctx, "call user.UserService/GetUser", slog.Any("user.GetUserRequest", s.logvalue_User_GetUserRequest(args)))
				ret, err := grpcfed.WithTimeout[backend.GetUserResponse](ctx, "user.UserService/GetUser", 5000000000 /* 5s */, func(ctx context.Context) (*backend.GetUserResponse, error) {
					b := grpcfed.NewExponentialBackOff(&grpcfed.ExponentialBackOffConfig{
						InitialInterval:     250000000, /* 250ms */
						RandomizationFactor: 0.5,
						Multiplier:          1.5,
						MaxInterval:         60000000000, /* 1m0s */
						MaxElapsedTime:      5000000000,  /* 5s */
					})
					b = grpcfed.BackOffWithMaxRetries(b, 1)
					b = grpcfed.BackOffWithContext(b, ctx)
					return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[backend.GetUserResponse]{
						Value:      value,
						If:         `error.code != google.rpc.Code.FAILED_PRECONDITION && error.code != google.rpc.Code.UNAVAILABLE`,
						CacheIndex: 38,
						BackOff:    b,
						Body: func() (*backend.GetUserResponse, error) {
							return s.client.User_UserServiceClient.GetUser(ctx, args)
						},
					})
				})
				if err != nil {
					grpcfed.SetGRPCError(ctx, value, err)
					var (
						defaultMsg     string
						defaultCode    grpcfed.Code
						defaultDetails []grpcfed.ProtoMessage
					)
					if stat, exists := grpcfed.GRPCStatusFromError(err); exists {
						defaultMsg = stat.Message()
						defaultCode = stat.Code()
						details := stat.Details()
						defaultDetails = make([]grpcfed.ProtoMessage, 0, len(details))
						for _, detail := range details {
							msg, ok := detail.(grpcfed.ProtoMessage)
							if ok {
								defaultDetails = append(defaultDetails, msg)
							}
						}
						_ = defaultMsg
						_ = defaultCode
						_ = defaultDetails
					}

					type localStatusType struct {
						status   *grpcfed.Status
						logLevel slog.Level
					}
					stat, handleErr := func() (*localStatusType, error) {
						var stat *grpcfed.Status
						{
							/*
								def {
								  name: "violation_type"
								  enum {
								    name: "bff.UserViolationType"
								    by: "user.UserFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))"
								  }
								}
							*/
							def_violation_type := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[UserViolationType, *localValueType]{
									Name: `violation_type`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v UserViolationType) error {
										value.vars.ViolationType = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (UserViolationType, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `user.UserFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))`,
											OutType:    reflect.TypeOf(backend.UserFailureCode(0)),
											CacheIndex: 39,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.UserFailureCode)
										return s.cast_User_UserFailureCode__to__Bff_UserViolationType(v)
									},
								})
							}

							if err := def_violation_type(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `violation_type != UserViolationType.USER_VIOLATION_TYPE_UNSPECIFIED`,
								CacheIndex: 40,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 41,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 42,
										Body: func(value *localValueType) error {
											if detail := grpcfed.PreconditionFailure(ctx, value, []*grpcfed.PreconditionFailureViolation{
												{
													Type:              `UserViolationType.name(violation_type)`,
													Subject:           `'GetUserDashboard'`,
													Desc:              `error.message`,
													TypeCacheIndex:    43,
													SubjectCacheIndex: 44,
													DescCacheIndex:    45,
												},
											}); detail != nil {
												details = append(details, detail)
											}
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `UserViolationType.attr(violation_type, 'ja-JP')`,
												CacheIndex: 46,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.FailedPreconditionCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						{
							/*
								def {
								  name: "error_reason"
								  enum {
								    name: "bff.UserErrorReason"
								    by: "user.UserErrorReason.value(error.error_info[?0].reason.orValue(''))"
								  }
								}
							*/
							def_error_reason := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[UserErrorReason, *localValueType]{
									Name: `error_reason`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v UserErrorReason) error {
										value.vars.ErrorReason = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (UserErrorReason, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `user.UserErrorReason.value(error.error_info[?0].reason.orValue(''))`,
											OutType:    reflect.TypeOf(backend.UserErrorReason(0)),
											CacheIndex: 47,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.UserErrorReason)
										return s.cast_User_UserErrorReason__to__Bff_UserErrorReason(v)
									},
								})
							}

							if err := def_error_reason(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `error.code == google.rpc.Code.UNAVAILABLE`,
								CacheIndex: 48,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 49,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 50,
										Body: func(value *localValueType) error {
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `UserErrorReason.attr(error_reason, 'ja-JP')`,
												CacheIndex: 51,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.UnavailableCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						return nil, nil
					}()
					if handleErr != nil {
						grpcfed.Logger(ctx).ErrorContext(ctx, "failed to handle error", slog.String("error", handleErr.Error()))
						// If it fails during error handling, return the original error.
						if err := s.errorHandler(ctx, BFFService_DependentMethod_User_UserService_GetUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					} else if stat != nil {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_User_UserService_GetUser, stat.status.Err()); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, stat.logLevel, grpcfed.LogAttrs(ctx))
						}
					} else {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_User_UserService_GetUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					}
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "the_user"
		  by: "user_res.user"
		}
	*/
	def_the_user := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.User, *localValueType]{
			Name: `the_user`,
			Type: grpcfed.CELObjectType("user.User"),
			Setter: func(value *localValueType, v *backend.User) error {
				value.vars.TheUser = v
				return nil
			},
			By:           `user_res.user`,
			ByCacheIndex: 52,
		})
	}

	/*
		def {
		  name: "orders_res"
		  call {
		    method: "order.OrderService/ListOrdersByUser"
		    request: [
		      { field: "user_id", by: "$.user_id" },
		      { field: "limit", by: "10" },
		      { field: "offset", by: "0" }
		    ]
		  }
		}
	*/
	def_orders_res := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.ListOrdersByUserResponse, *localValueType]{
			Name: `orders_res`,
			Type: grpcfed.CELObjectType("order.ListOrdersByUserResponse"),
			Setter: func(value *localValueType, v *backend.ListOrdersByUserResponse) error {
				value.vars.OrdersRes = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &backend.ListOrdersByUserRequest{}
				// { field: "user_id", by: "$.user_id" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `$.user_id`,
					CacheIndex: 53,
					Setter: func(v string) error {
						args.UserId = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { field: "limit", by: "10" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int32]{
					Value:      value,
					Expr:       `10`,
					CacheIndex: 54,
					Setter: func(v int32) error {
						args.Limit = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { field: "offset", by: "0" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int32]{
					Value:      value,
					Expr:       `0`,
					CacheIndex: 55,
					Setter: func(v int32) error {
						args.Offset = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				grpcfed.Logger(ctx).DebugContext(ctx, "call order.OrderService/ListOrdersByUser", slog.Any("order.ListOrdersByUserRequest", s.logvalue_Order_ListOrdersByUserRequest(args)))
				ret, err := grpcfed.WithTimeout[backend.ListOrdersByUserResponse](ctx, "order.OrderService/ListOrdersByUser", 5000000000 /* 5s */, func(ctx context.Context) (*backend.ListOrdersByUserResponse, error) {
					b := grpcfed.NewExponentialBackOff(&grpcfed.ExponentialBackOffConfig{
						InitialInterval:     250000000, /* 250ms */
						RandomizationFactor: 0.5,
						Multiplier:          1.5,
						MaxInterval:         60000000000, /* 1m0s */
						MaxElapsedTime:      5000000000,  /* 5s */
					})
					b = grpcfed.BackOffWithMaxRetries(b, 1)
					b = grpcfed.BackOffWithContext(b, ctx)
					return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[backend.ListOrdersByUserResponse]{
						Value:      value,
						If:         `error.code != google.rpc.Code.FAILED_PRECONDITION && error.code != google.rpc.Code.UNAVAILABLE`,
						CacheIndex: 56,
						BackOff:    b,
						Body: func() (*backend.ListOrdersByUserResponse, error) {
							return s.client.Order_OrderServiceClient.ListOrdersByUser(ctx, args)
						},
					})
				})
				if err != nil {
					grpcfed.SetGRPCError(ctx, value, err)
					var (
						defaultMsg     string
						defaultCode    grpcfed.Code
						defaultDetails []grpcfed.ProtoMessage
					)
					if stat, exists := grpcfed.GRPCStatusFromError(err); exists {
						defaultMsg = stat.Message()
						defaultCode = stat.Code()
						details := stat.Details()
						defaultDetails = make([]grpcfed.ProtoMessage, 0, len(details))
						for _, detail := range details {
							msg, ok := detail.(grpcfed.ProtoMessage)
							if ok {
								defaultDetails = append(defaultDetails, msg)
							}
						}
						_ = defaultMsg
						_ = defaultCode
						_ = defaultDetails
					}

					type localStatusType struct {
						status   *grpcfed.Status
						logLevel slog.Level
					}
					stat, handleErr := func() (*localStatusType, error) {
						var stat *grpcfed.Status
						{
							/*
								def {
								  name: "order_violation_type"
								  enum {
								    name: "bff.OrderViolationType"
								    by: "order.OrderFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))"
								  }
								}
							*/
							def_order_violation_type := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[OrderViolationType, *localValueType]{
									Name: `order_violation_type`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v OrderViolationType) error {
										value.vars.OrderViolationType = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (OrderViolationType, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `order.OrderFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))`,
											OutType:    reflect.TypeOf(backend.OrderFailureCode(0)),
											CacheIndex: 57,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.OrderFailureCode)
										return s.cast_Order_OrderFailureCode__to__Bff_OrderViolationType(v)
									},
								})
							}

							if err := def_order_violation_type(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `order_violation_type != OrderViolationType.ORDER_VIOLATION_TYPE_UNSPECIFIED`,
								CacheIndex: 58,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 59,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 60,
										Body: func(value *localValueType) error {
											if detail := grpcfed.PreconditionFailure(ctx, value, []*grpcfed.PreconditionFailureViolation{
												{
													Type:              `OrderViolationType.name(order_violation_type)`,
													Subject:           `'GetUserDashboard'`,
													Desc:              `error.message`,
													TypeCacheIndex:    61,
													SubjectCacheIndex: 62,
													DescCacheIndex:    63,
												},
											}); detail != nil {
												details = append(details, detail)
											}
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `OrderViolationType.attr(order_violation_type, 'ja-JP')`,
												CacheIndex: 64,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.FailedPreconditionCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						{
							/*
								def {
								  name: "order_error_reason"
								  enum {
								    name: "bff.OrderErrorReason"
								    by: "order.OrderErrorReason.value(error.error_info[?0].reason.orValue(''))"
								  }
								}
							*/
							def_order_error_reason := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[OrderErrorReason, *localValueType]{
									Name: `order_error_reason`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v OrderErrorReason) error {
										value.vars.OrderErrorReason = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (OrderErrorReason, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `order.OrderErrorReason.value(error.error_info[?0].reason.orValue(''))`,
											OutType:    reflect.TypeOf(backend.OrderErrorReason(0)),
											CacheIndex: 65,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.OrderErrorReason)
										return s.cast_Order_OrderErrorReason__to__Bff_OrderErrorReason(v)
									},
								})
							}

							if err := def_order_error_reason(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `error.code == google.rpc.Code.UNAVAILABLE`,
								CacheIndex: 66,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 67,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 68,
										Body: func(value *localValueType) error {
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `OrderErrorReason.attr(order_error_reason, 'ja-JP')`,
												CacheIndex: 69,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.UnavailableCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						return nil, nil
					}()
					if handleErr != nil {
						grpcfed.Logger(ctx).ErrorContext(ctx, "failed to handle error", slog.String("error", handleErr.Error()))
						// If it fails during error handling, return the original error.
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Order_OrderService_ListOrdersByUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					} else if stat != nil {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Order_OrderService_ListOrdersByUser, stat.status.Err()); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, stat.logLevel, grpcfed.LogAttrs(ctx))
						}
					} else {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Order_OrderService_ListOrdersByUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					}
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "products_res"
		  call {
		    method: "product.ProductService/ListProducts"
		    request: [
		      { field: "limit", by: "5" },
		      { field: "offset", by: "0" }
		    ]
		  }
		}
	*/
	def_products_res := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.ListProductsResponse, *localValueType]{
			Name: `products_res`,
			Type: grpcfed.CELObjectType("product.ListProductsResponse"),
			Setter: func(value *localValueType, v *backend.ListProductsResponse) error {
				value.vars.ProductsRes = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &backend.ListProductsRequest{}
				// { field: "limit", by: "5" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int32]{
					Value:      value,
					Expr:       `5`,
					CacheIndex: 70,
					Setter: func(v int32) error {
						args.Limit = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { field: "offset", by: "0" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int32]{
					Value:      value,
					Expr:       `0`,
					CacheIndex: 71,
					Setter: func(v int32) error {
						args.Offset = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				grpcfed.Logger(ctx).DebugContext(ctx, "call product.ProductService/ListProducts", slog.Any("product.ListProductsRequest", s.logvalue_Product_ListProductsRequest(args)))
				ret, err := grpcfed.WithTimeout[backend.ListProductsResponse](ctx, "product.ProductService/ListProducts", 5000000000 /* 5s */, func(ctx context.Context) (*backend.ListProductsResponse, error) {
					b := grpcfed.NewExponentialBackOff(&grpcfed.ExponentialBackOffConfig{
						InitialInterval:     250000000, /* 250ms */
						RandomizationFactor: 0.5,
						Multiplier:          1.5,
						MaxInterval:         60000000000, /* 1m0s */
						MaxElapsedTime:      5000000000,  /* 5s */
					})
					b = grpcfed.BackOffWithMaxRetries(b, 1)
					b = grpcfed.BackOffWithContext(b, ctx)
					return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[backend.ListProductsResponse]{
						Value:      value,
						If:         `error.code != google.rpc.Code.FAILED_PRECONDITION && error.code != google.rpc.Code.UNAVAILABLE`,
						CacheIndex: 72,
						BackOff:    b,
						Body: func() (*backend.ListProductsResponse, error) {
							return s.client.Product_ProductServiceClient.ListProducts(ctx, args)
						},
					})
				})
				if err != nil {
					grpcfed.SetGRPCError(ctx, value, err)
					var (
						defaultMsg     string
						defaultCode    grpcfed.Code
						defaultDetails []grpcfed.ProtoMessage
					)
					if stat, exists := grpcfed.GRPCStatusFromError(err); exists {
						defaultMsg = stat.Message()
						defaultCode = stat.Code()
						details := stat.Details()
						defaultDetails = make([]grpcfed.ProtoMessage, 0, len(details))
						for _, detail := range details {
							msg, ok := detail.(grpcfed.ProtoMessage)
							if ok {
								defaultDetails = append(defaultDetails, msg)
							}
						}
						_ = defaultMsg
						_ = defaultCode
						_ = defaultDetails
					}

					type localStatusType struct {
						status   *grpcfed.Status
						logLevel slog.Level
					}
					stat, handleErr := func() (*localStatusType, error) {
						var stat *grpcfed.Status
						{
							/*
								def {
								  name: "product_violation_type"
								  enum {
								    name: "bff.ProductViolationType"
								    by: "product.ProductFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))"
								  }
								}
							*/
							def_product_violation_type := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[ProductViolationType, *localValueType]{
									Name: `product_violation_type`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v ProductViolationType) error {
										value.vars.ProductViolationType = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (ProductViolationType, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `product.ProductFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))`,
											OutType:    reflect.TypeOf(backend.ProductFailureCode(0)),
											CacheIndex: 73,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.ProductFailureCode)
										return s.cast_Product_ProductFailureCode__to__Bff_ProductViolationType(v)
									},
								})
							}

							if err := def_product_violation_type(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `product_violation_type != ProductViolationType.PRODUCT_VIOLATION_TYPE_UNSPECIFIED`,
								CacheIndex: 74,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 75,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 76,
										Body: func(value *localValueType) error {
											if detail := grpcfed.PreconditionFailure(ctx, value, []*grpcfed.PreconditionFailureViolation{
												{
													Type:              `ProductViolationType.name(product_violation_type)`,
													Subject:           `'GetUserDashboard'`,
													Desc:              `error.message`,
													TypeCacheIndex:    77,
													SubjectCacheIndex: 78,
													DescCacheIndex:    79,
												},
											}); detail != nil {
												details = append(details, detail)
											}
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `ProductViolationType.attr(product_violation_type, 'ja-JP')`,
												CacheIndex: 80,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.FailedPreconditionCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						{
							/*
								def {
								  name: "product_error_reason"
								  enum {
								    name: "bff.ProductErrorReason"
								    by: "product.ProductErrorReason.value(error.error_info[?0].reason.orValue(''))"
								  }
								}
							*/
							def_product_error_reason := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[ProductErrorReason, *localValueType]{
									Name: `product_error_reason`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v ProductErrorReason) error {
										value.vars.ProductErrorReason = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (ProductErrorReason, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `product.ProductErrorReason.value(error.error_info[?0].reason.orValue(''))`,
											OutType:    reflect.TypeOf(backend.ProductErrorReason(0)),
											CacheIndex: 81,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.ProductErrorReason)
										return s.cast_Product_ProductErrorReason__to__Bff_ProductErrorReason(v)
									},
								})
							}

							if err := def_product_error_reason(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `error.code == google.rpc.Code.UNAVAILABLE`,
								CacheIndex: 82,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 83,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 84,
										Body: func(value *localValueType) error {
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `ProductErrorReason.attr(product_error_reason, 'ja-JP')`,
												CacheIndex: 85,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.UnavailableCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						return nil, nil
					}()
					if handleErr != nil {
						grpcfed.Logger(ctx).ErrorContext(ctx, "failed to handle error", slog.String("error", handleErr.Error()))
						// If it fails during error handling, return the original error.
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Product_ProductService_ListProducts, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					} else if stat != nil {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Product_ProductService_ListProducts, stat.status.Err()); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, stat.logLevel, grpcfed.LogAttrs(ctx))
						}
					} else {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Product_ProductService_ListProducts, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					}
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "stats"
		  message {
		    name: "UserStatistics"
		    args: [
		      { name: "total_orders", by: "orders_res.total" },
		      { name: "orders", by: "orders_res.orders" }
		    ]
		  }
		}
	*/
	def_stats := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*UserStatistics, *localValueType]{
			Name: `stats`,
			Type: grpcfed.CELObjectType("bff.UserStatistics"),
			Setter: func(value *localValueType, v *UserStatistics) error {
				value.vars.Stats = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &BFFService_Bff_UserStatisticsArgument{}
				// { name: "total_orders", by: "orders_res.total" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int64]{
					Value:      value,
					Expr:       `orders_res.total`,
					CacheIndex: 86,
					Setter: func(v int64) error {
						args.TotalOrders = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { name: "orders", by: "orders_res.orders" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[[]*backend.Order]{
					Value:      value,
					Expr:       `orders_res.orders`,
					CacheIndex: 87,
					Setter: func(v []*backend.Order) error {
						args.Orders = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				ret, err := s.resolve_Bff_UserStatistics(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	// A tree view of message dependencies is shown below.
	/*
	               products_res ─┐
	   orders_res ─┐             │
	                      stats ─┤
	     user_res ─┐             │
	                   the_user ─┤
	*/
	eg, ctx1 := grpcfed.ErrorGroupWithContext(ctx)

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_products_res(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_orders_res(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_stats(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_user_res(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_the_user(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	if err := eg.Wait(); err != nil {
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.BFFService_Bff_GetUserDashboardResponseVariable.ErrorReason = value.vars.ErrorReason
	req.BFFService_Bff_GetUserDashboardResponseVariable.OrderErrorReason = value.vars.OrderErrorReason
	req.BFFService_Bff_GetUserDashboardResponseVariable.OrderViolationType = value.vars.OrderViolationType
	req.BFFService_Bff_GetUserDashboardResponseVariable.OrdersRes = value.vars.OrdersRes
	req.BFFService_Bff_GetUserDashboardResponseVariable.ProductErrorReason = value.vars.ProductErrorReason
	req.BFFService_Bff_GetUserDashboardResponseVariable.ProductViolationType = value.vars.ProductViolationType
	req.BFFService_Bff_GetUserDashboardResponseVariable.ProductsRes = value.vars.ProductsRes
	req.BFFService_Bff_GetUserDashboardResponseVariable.Stats = value.vars.Stats
	req.BFFService_Bff_GetUserDashboardResponseVariable.TheUser = value.vars.TheUser
	req.BFFService_Bff_GetUserDashboardResponseVariable.UserRes = value.vars.UserRes
	req.BFFService_Bff_GetUserDashboardResponseVariable.ViolationType = value.vars.ViolationType

	// create a message value to be returned.
	ret := &GetUserDashboardResponse{}

	// field binding section.
	// (grpc.federation.field).by = "the_user"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*backend.User]{
		Value:      value,
		Expr:       `the_user`,
		CacheIndex: 88,
		Setter: func(v *backend.User) error {
			ret.User = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "orders_res.orders"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[[]*backend.Order]{
		Value:      value,
		Expr:       `orders_res.orders`,
		CacheIndex: 89,
		Setter: func(v []*backend.Order) error {
			ret.RecentOrders = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "products_res.products"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[[]*backend.Product]{
		Value:      value,
		Expr:       `products_res.products`,
		CacheIndex: 90,
		Setter: func(v []*backend.Product) error {
			ret.RecommendedProducts = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "stats"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*UserStatistics]{
		Value:      value,
		Expr:       `stats`,
		CacheIndex: 91,
		Setter: func(v *UserStatistics) error {
			ret.Statistics = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved bff.GetUserDashboardResponse", slog.Any("bff.GetUserDashboardResponse", s.logvalue_Bff_GetUserDashboardResponse(ret)))
	return ret, nil
}

// resolve_Bff_GetUserWithOrdersResponse resolve "bff.GetUserWithOrdersResponse" message.
func (s *BFFService) resolve_Bff_GetUserWithOrdersResponse(ctx context.Context, req *BFFService_Bff_GetUserWithOrdersResponseArgument) (*GetUserWithOrdersResponse, error) {
	ctx, span := s.tracer.Start(ctx, "bff.GetUserWithOrdersResponse")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve bff.GetUserWithOrdersResponse", slog.Any("message_args", s.logvalue_Bff_GetUserWithOrdersResponseArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			ErrorReason        UserErrorReason
			OrderErrorReason   OrderErrorReason
			OrderViolationType OrderViolationType
			OrdersRes          *backend.ListOrdersByUserResponse
			UserRes            *backend.GetUserResponse
			ViolationType      UserViolationType
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.bff.GetUserWithOrdersResponseArgument", req)}
	/*
		def {
		  name: "user_res"
		  call {
		    method: "user.UserService/GetUser"
		    request { field: "user_id", by: "$.user_id" }
		  }
		}
	*/
	def_user_res := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.GetUserResponse, *localValueType]{
			Name: `user_res`,
			Type: grpcfed.CELObjectType("user.GetUserResponse"),
			Setter: func(value *localValueType, v *backend.GetUserResponse) error {
				value.vars.UserRes = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &backend.GetUserRequest{}
				// { field: "user_id", by: "$.user_id" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `$.user_id`,
					CacheIndex: 92,
					Setter: func(v string) error {
						args.UserId = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				grpcfed.Logger(ctx).DebugContext(ctx, "call user.UserService/GetUser", slog.Any("user.GetUserRequest", s.logvalue_User_GetUserRequest(args)))
				ret, err := grpcfed.WithTimeout[backend.GetUserResponse](ctx, "user.UserService/GetUser", 5000000000 /* 5s */, func(ctx context.Context) (*backend.GetUserResponse, error) {
					b := grpcfed.NewExponentialBackOff(&grpcfed.ExponentialBackOffConfig{
						InitialInterval:     250000000, /* 250ms */
						RandomizationFactor: 0.5,
						Multiplier:          1.5,
						MaxInterval:         60000000000, /* 1m0s */
						MaxElapsedTime:      5000000000,  /* 5s */
					})
					b = grpcfed.BackOffWithMaxRetries(b, 1)
					b = grpcfed.BackOffWithContext(b, ctx)
					return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[backend.GetUserResponse]{
						Value:      value,
						If:         `error.code != google.rpc.Code.FAILED_PRECONDITION && error.code != google.rpc.Code.UNAVAILABLE`,
						CacheIndex: 93,
						BackOff:    b,
						Body: func() (*backend.GetUserResponse, error) {
							return s.client.User_UserServiceClient.GetUser(ctx, args)
						},
					})
				})
				if err != nil {
					grpcfed.SetGRPCError(ctx, value, err)
					var (
						defaultMsg     string
						defaultCode    grpcfed.Code
						defaultDetails []grpcfed.ProtoMessage
					)
					if stat, exists := grpcfed.GRPCStatusFromError(err); exists {
						defaultMsg = stat.Message()
						defaultCode = stat.Code()
						details := stat.Details()
						defaultDetails = make([]grpcfed.ProtoMessage, 0, len(details))
						for _, detail := range details {
							msg, ok := detail.(grpcfed.ProtoMessage)
							if ok {
								defaultDetails = append(defaultDetails, msg)
							}
						}
						_ = defaultMsg
						_ = defaultCode
						_ = defaultDetails
					}

					type localStatusType struct {
						status   *grpcfed.Status
						logLevel slog.Level
					}
					stat, handleErr := func() (*localStatusType, error) {
						var stat *grpcfed.Status
						{
							/*
								def {
								  name: "violation_type"
								  enum {
								    name: "bff.UserViolationType"
								    by: "user.UserFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))"
								  }
								}
							*/
							def_violation_type := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[UserViolationType, *localValueType]{
									Name: `violation_type`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v UserViolationType) error {
										value.vars.ViolationType = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (UserViolationType, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `user.UserFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))`,
											OutType:    reflect.TypeOf(backend.UserFailureCode(0)),
											CacheIndex: 94,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.UserFailureCode)
										return s.cast_User_UserFailureCode__to__Bff_UserViolationType(v)
									},
								})
							}

							if err := def_violation_type(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `violation_type != UserViolationType.USER_VIOLATION_TYPE_UNSPECIFIED`,
								CacheIndex: 95,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 96,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 97,
										Body: func(value *localValueType) error {
											if detail := grpcfed.PreconditionFailure(ctx, value, []*grpcfed.PreconditionFailureViolation{
												{
													Type:              `UserViolationType.name(violation_type)`,
													Subject:           `'GetUserWithOrders'`,
													Desc:              `error.message`,
													TypeCacheIndex:    98,
													SubjectCacheIndex: 99,
													DescCacheIndex:    100,
												},
											}); detail != nil {
												details = append(details, detail)
											}
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `UserViolationType.attr(violation_type, 'ja-JP')`,
												CacheIndex: 101,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.FailedPreconditionCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						{
							/*
								def {
								  name: "error_reason"
								  enum {
								    name: "bff.UserErrorReason"
								    by: "user.UserErrorReason.value(error.error_info[?0].reason.orValue(''))"
								  }
								}
							*/
							def_error_reason := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[UserErrorReason, *localValueType]{
									Name: `error_reason`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v UserErrorReason) error {
										value.vars.ErrorReason = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (UserErrorReason, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `user.UserErrorReason.value(error.error_info[?0].reason.orValue(''))`,
											OutType:    reflect.TypeOf(backend.UserErrorReason(0)),
											CacheIndex: 102,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.UserErrorReason)
										return s.cast_User_UserErrorReason__to__Bff_UserErrorReason(v)
									},
								})
							}

							if err := def_error_reason(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `error.code == google.rpc.Code.UNAVAILABLE`,
								CacheIndex: 103,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 104,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 105,
										Body: func(value *localValueType) error {
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `UserErrorReason.attr(error_reason, 'ja-JP')`,
												CacheIndex: 106,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.UnavailableCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						return nil, nil
					}()
					if handleErr != nil {
						grpcfed.Logger(ctx).ErrorContext(ctx, "failed to handle error", slog.String("error", handleErr.Error()))
						// If it fails during error handling, return the original error.
						if err := s.errorHandler(ctx, BFFService_DependentMethod_User_UserService_GetUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					} else if stat != nil {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_User_UserService_GetUser, stat.status.Err()); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, stat.logLevel, grpcfed.LogAttrs(ctx))
						}
					} else {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_User_UserService_GetUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					}
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "orders_res"
		  call {
		    method: "order.OrderService/ListOrdersByUser"
		    request: [
		      { field: "user_id", by: "$.user_id" },
		      { field: "limit", by: "10" },
		      { field: "offset", by: "0" }
		    ]
		  }
		}
	*/
	def_orders_res := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.ListOrdersByUserResponse, *localValueType]{
			Name: `orders_res`,
			Type: grpcfed.CELObjectType("order.ListOrdersByUserResponse"),
			Setter: func(value *localValueType, v *backend.ListOrdersByUserResponse) error {
				value.vars.OrdersRes = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &backend.ListOrdersByUserRequest{}
				// { field: "user_id", by: "$.user_id" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `$.user_id`,
					CacheIndex: 107,
					Setter: func(v string) error {
						args.UserId = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { field: "limit", by: "10" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int32]{
					Value:      value,
					Expr:       `10`,
					CacheIndex: 108,
					Setter: func(v int32) error {
						args.Limit = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { field: "offset", by: "0" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int32]{
					Value:      value,
					Expr:       `0`,
					CacheIndex: 109,
					Setter: func(v int32) error {
						args.Offset = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				grpcfed.Logger(ctx).DebugContext(ctx, "call order.OrderService/ListOrdersByUser", slog.Any("order.ListOrdersByUserRequest", s.logvalue_Order_ListOrdersByUserRequest(args)))
				ret, err := grpcfed.WithTimeout[backend.ListOrdersByUserResponse](ctx, "order.OrderService/ListOrdersByUser", 5000000000 /* 5s */, func(ctx context.Context) (*backend.ListOrdersByUserResponse, error) {
					b := grpcfed.NewExponentialBackOff(&grpcfed.ExponentialBackOffConfig{
						InitialInterval:     250000000, /* 250ms */
						RandomizationFactor: 0.5,
						Multiplier:          1.5,
						MaxInterval:         60000000000, /* 1m0s */
						MaxElapsedTime:      5000000000,  /* 5s */
					})
					b = grpcfed.BackOffWithMaxRetries(b, 1)
					b = grpcfed.BackOffWithContext(b, ctx)
					return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[backend.ListOrdersByUserResponse]{
						Value:      value,
						If:         `error.code != google.rpc.Code.FAILED_PRECONDITION && error.code != google.rpc.Code.UNAVAILABLE`,
						CacheIndex: 110,
						BackOff:    b,
						Body: func() (*backend.ListOrdersByUserResponse, error) {
							return s.client.Order_OrderServiceClient.ListOrdersByUser(ctx, args)
						},
					})
				})
				if err != nil {
					grpcfed.SetGRPCError(ctx, value, err)
					var (
						defaultMsg     string
						defaultCode    grpcfed.Code
						defaultDetails []grpcfed.ProtoMessage
					)
					if stat, exists := grpcfed.GRPCStatusFromError(err); exists {
						defaultMsg = stat.Message()
						defaultCode = stat.Code()
						details := stat.Details()
						defaultDetails = make([]grpcfed.ProtoMessage, 0, len(details))
						for _, detail := range details {
							msg, ok := detail.(grpcfed.ProtoMessage)
							if ok {
								defaultDetails = append(defaultDetails, msg)
							}
						}
						_ = defaultMsg
						_ = defaultCode
						_ = defaultDetails
					}

					type localStatusType struct {
						status   *grpcfed.Status
						logLevel slog.Level
					}
					stat, handleErr := func() (*localStatusType, error) {
						var stat *grpcfed.Status
						{
							/*
								def {
								  name: "order_violation_type"
								  enum {
								    name: "bff.OrderViolationType"
								    by: "order.OrderFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))"
								  }
								}
							*/
							def_order_violation_type := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[OrderViolationType, *localValueType]{
									Name: `order_violation_type`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v OrderViolationType) error {
										value.vars.OrderViolationType = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (OrderViolationType, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `order.OrderFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))`,
											OutType:    reflect.TypeOf(backend.OrderFailureCode(0)),
											CacheIndex: 111,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.OrderFailureCode)
										return s.cast_Order_OrderFailureCode__to__Bff_OrderViolationType(v)
									},
								})
							}

							if err := def_order_violation_type(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `order_violation_type != OrderViolationType.ORDER_VIOLATION_TYPE_UNSPECIFIED`,
								CacheIndex: 112,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 113,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 114,
										Body: func(value *localValueType) error {
											if detail := grpcfed.PreconditionFailure(ctx, value, []*grpcfed.PreconditionFailureViolation{
												{
													Type:              `OrderViolationType.name(order_violation_type)`,
													Subject:           `'GetUserWithOrders'`,
													Desc:              `error.message`,
													TypeCacheIndex:    115,
													SubjectCacheIndex: 116,
													DescCacheIndex:    117,
												},
											}); detail != nil {
												details = append(details, detail)
											}
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `OrderViolationType.attr(order_violation_type, 'ja-JP')`,
												CacheIndex: 118,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.FailedPreconditionCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						{
							/*
								def {
								  name: "order_error_reason"
								  enum {
								    name: "bff.OrderErrorReason"
								    by: "order.OrderErrorReason.value(error.error_info[?0].reason.orValue(''))"
								  }
								}
							*/
							def_order_error_reason := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[OrderErrorReason, *localValueType]{
									Name: `order_error_reason`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v OrderErrorReason) error {
										value.vars.OrderErrorReason = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (OrderErrorReason, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `order.OrderErrorReason.value(error.error_info[?0].reason.orValue(''))`,
											OutType:    reflect.TypeOf(backend.OrderErrorReason(0)),
											CacheIndex: 119,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.OrderErrorReason)
										return s.cast_Order_OrderErrorReason__to__Bff_OrderErrorReason(v)
									},
								})
							}

							if err := def_order_error_reason(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `error.code == google.rpc.Code.UNAVAILABLE`,
								CacheIndex: 120,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 121,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 122,
										Body: func(value *localValueType) error {
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `OrderErrorReason.attr(order_error_reason, 'ja-JP')`,
												CacheIndex: 123,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.UnavailableCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						return nil, nil
					}()
					if handleErr != nil {
						grpcfed.Logger(ctx).ErrorContext(ctx, "failed to handle error", slog.String("error", handleErr.Error()))
						// If it fails during error handling, return the original error.
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Order_OrderService_ListOrdersByUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					} else if stat != nil {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Order_OrderService_ListOrdersByUser, stat.status.Err()); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, stat.logLevel, grpcfed.LogAttrs(ctx))
						}
					} else {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Order_OrderService_ListOrdersByUser, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					}
				}
				return ret, nil
			},
		})
	}

	// A tree view of message dependencies is shown below.
	/*
	   orders_res ─┐
	     user_res ─┤
	*/
	eg, ctx1 := grpcfed.ErrorGroupWithContext(ctx)

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_orders_res(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_user_res(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	if err := eg.Wait(); err != nil {
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.BFFService_Bff_GetUserWithOrdersResponseVariable.ErrorReason = value.vars.ErrorReason
	req.BFFService_Bff_GetUserWithOrdersResponseVariable.OrderErrorReason = value.vars.OrderErrorReason
	req.BFFService_Bff_GetUserWithOrdersResponseVariable.OrderViolationType = value.vars.OrderViolationType
	req.BFFService_Bff_GetUserWithOrdersResponseVariable.OrdersRes = value.vars.OrdersRes
	req.BFFService_Bff_GetUserWithOrdersResponseVariable.UserRes = value.vars.UserRes
	req.BFFService_Bff_GetUserWithOrdersResponseVariable.ViolationType = value.vars.ViolationType

	// create a message value to be returned.
	ret := &GetUserWithOrdersResponse{}

	// field binding section.
	// (grpc.federation.field).by = "user_res.user"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*backend.User]{
		Value:      value,
		Expr:       `user_res.user`,
		CacheIndex: 124,
		Setter: func(v *backend.User) error {
			ret.User = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "orders_res.orders"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[[]*backend.Order]{
		Value:      value,
		Expr:       `orders_res.orders`,
		CacheIndex: 125,
		Setter: func(v []*backend.Order) error {
			ret.Orders = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "orders_res.total"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int32]{
		Value:      value,
		Expr:       `orders_res.total`,
		CacheIndex: 126,
		Setter: func(v int32) error {
			ret.TotalOrders = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved bff.GetUserWithOrdersResponse", slog.Any("bff.GetUserWithOrdersResponse", s.logvalue_Bff_GetUserWithOrdersResponse(ret)))
	return ret, nil
}

// resolve_Bff_ProductDetail resolve "bff.ProductDetail" message.
func (s *BFFService) resolve_Bff_ProductDetail(ctx context.Context, req *BFFService_Bff_ProductDetailArgument) (*ProductDetail, error) {
	ctx, span := s.tracer.Start(ctx, "bff.ProductDetail")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve bff.ProductDetail", slog.Any("message_args", s.logvalue_Bff_ProductDetailArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			ErrorReason          ProductErrorReason
			ProductRes           *backend.GetProductResponse
			ProductViolationType ProductViolationType
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.bff.ProductDetailArgument", req)}
	/*
		def {
		  name: "product_res"
		  call {
		    method: "product.ProductService/GetProduct"
		    request { field: "product_id", by: "$.item.product_id" }
		  }
		}
	*/
	def_product_res := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*backend.GetProductResponse, *localValueType]{
			Name: `product_res`,
			Type: grpcfed.CELObjectType("product.GetProductResponse"),
			Setter: func(value *localValueType, v *backend.GetProductResponse) error {
				value.vars.ProductRes = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &backend.GetProductRequest{}
				// { field: "product_id", by: "$.item.product_id" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `$.item.product_id`,
					CacheIndex: 127,
					Setter: func(v string) error {
						args.ProductId = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				grpcfed.Logger(ctx).DebugContext(ctx, "call product.ProductService/GetProduct", slog.Any("product.GetProductRequest", s.logvalue_Product_GetProductRequest(args)))
				ret, err := grpcfed.WithTimeout[backend.GetProductResponse](ctx, "product.ProductService/GetProduct", 5000000000 /* 5s */, func(ctx context.Context) (*backend.GetProductResponse, error) {
					b := grpcfed.NewExponentialBackOff(&grpcfed.ExponentialBackOffConfig{
						InitialInterval:     250000000, /* 250ms */
						RandomizationFactor: 0.5,
						Multiplier:          1.5,
						MaxInterval:         60000000000, /* 1m0s */
						MaxElapsedTime:      5000000000,  /* 5s */
					})
					b = grpcfed.BackOffWithMaxRetries(b, 1)
					b = grpcfed.BackOffWithContext(b, ctx)
					return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[backend.GetProductResponse]{
						Value:      value,
						If:         `error.code != google.rpc.Code.FAILED_PRECONDITION && error.code != google.rpc.Code.UNAVAILABLE`,
						CacheIndex: 128,
						BackOff:    b,
						Body: func() (*backend.GetProductResponse, error) {
							return s.client.Product_ProductServiceClient.GetProduct(ctx, args)
						},
					})
				})
				if err != nil {
					grpcfed.SetGRPCError(ctx, value, err)
					var (
						defaultMsg     string
						defaultCode    grpcfed.Code
						defaultDetails []grpcfed.ProtoMessage
					)
					if stat, exists := grpcfed.GRPCStatusFromError(err); exists {
						defaultMsg = stat.Message()
						defaultCode = stat.Code()
						details := stat.Details()
						defaultDetails = make([]grpcfed.ProtoMessage, 0, len(details))
						for _, detail := range details {
							msg, ok := detail.(grpcfed.ProtoMessage)
							if ok {
								defaultDetails = append(defaultDetails, msg)
							}
						}
						_ = defaultMsg
						_ = defaultCode
						_ = defaultDetails
					}

					type localStatusType struct {
						status   *grpcfed.Status
						logLevel slog.Level
					}
					stat, handleErr := func() (*localStatusType, error) {
						var stat *grpcfed.Status
						{
							/*
								def {
								  name: "product_violation_type"
								  enum {
								    name: "bff.ProductViolationType"
								    by: "product.ProductFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))"
								  }
								}
							*/
							def_product_violation_type := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[ProductViolationType, *localValueType]{
									Name: `product_violation_type`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v ProductViolationType) error {
										value.vars.ProductViolationType = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (ProductViolationType, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `product.ProductFailureCode.value(error.precondition_failures[?0].violations[?0].type.orValue(''))`,
											OutType:    reflect.TypeOf(backend.ProductFailureCode(0)),
											CacheIndex: 129,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.ProductFailureCode)
										return s.cast_Product_ProductFailureCode__to__Bff_ProductViolationType(v)
									},
								})
							}

							if err := def_product_violation_type(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `product_violation_type != ProductViolationType.PRODUCT_VIOLATION_TYPE_UNSPECIFIED`,
								CacheIndex: 130,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 131,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 132,
										Body: func(value *localValueType) error {
											if detail := grpcfed.PreconditionFailure(ctx, value, []*grpcfed.PreconditionFailureViolation{
												{
													Type:              `ProductViolationType.name(product_violation_type)`,
													Subject:           `'GetOrderDetails/ProductDetail'`,
													Desc:              `error.message`,
													TypeCacheIndex:    133,
													SubjectCacheIndex: 134,
													DescCacheIndex:    135,
												},
											}); detail != nil {
												details = append(details, detail)
											}
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `ProductViolationType.attr(product_violation_type, 'ja-JP')`,
												CacheIndex: 136,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.FailedPreconditionCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						{
							/*
								def {
								  name: "error_reason"
								  enum {
								    name: "bff.ProductErrorReason"
								    by: "product.ProductErrorReason.value(error.error_info[?0].reason.orValue(''))"
								  }
								}
							*/
							def_error_reason := func(ctx context.Context) error {
								return grpcfed.EvalDef(ctx, value, grpcfed.Def[ProductErrorReason, *localValueType]{
									Name: `error_reason`,
									Type: grpcfed.CELIntType,
									Setter: func(value *localValueType, v ProductErrorReason) error {
										value.vars.ErrorReason = v
										return nil
									},
									Enum: func(ctx context.Context, value *localValueType) (ProductErrorReason, error) {
										src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
											Value:      value,
											Expr:       `product.ProductErrorReason.value(error.error_info[?0].reason.orValue(''))`,
											OutType:    reflect.TypeOf(backend.ProductErrorReason(0)),
											CacheIndex: 137,
										})
										if err != nil {
											return 0, err
										}
										v := src.(backend.ProductErrorReason)
										return s.cast_Product_ProductErrorReason__to__Bff_ProductErrorReason(v)
									},
								})
							}

							if err := def_error_reason(ctx); err != nil {
								grpcfed.RecordErrorToSpan(ctx, err)
								return nil, err
							}
							if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
								Value:      value,
								Expr:       `error.code == google.rpc.Code.UNAVAILABLE`,
								CacheIndex: 138,
								Body: func(value *localValueType) error {
									errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
										Value:      value,
										Expr:       `''`,
										OutType:    reflect.TypeOf(""),
										CacheIndex: 139,
									})
									if err != nil {
										return err
									}
									errorMessage := errmsg.(string)
									var details []grpcfed.ProtoMessage
									if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
										Value:      value,
										Expr:       `true`,
										CacheIndex: 140,
										Body: func(value *localValueType) error {
											if detail := grpcfed.LocalizedMessage(ctx, &grpcfed.LocalizedMessageParam{
												Value:      value,
												Locale:     "ja-JP",
												Message:    `ProductErrorReason.attr(error_reason, 'ja-JP')`,
												CacheIndex: 141,
											}); detail != nil {
												details = append(details, detail)
											}
											return nil
										},
									}); err != nil {
										return err
									}

									var code grpcfed.Code
									code = grpcfed.UnavailableCode
									status := grpcfed.NewGRPCStatus(code, errorMessage)
									statusWithDetails, err := status.WithDetails(details...)
									if err != nil {
										grpcfed.Logger(ctx).ErrorContext(ctx, "failed setting error details", slog.String("error", err.Error()))
										stat = status
									} else {
										stat = statusWithDetails
									}
									return nil
								},
							}); err != nil {
								return nil, err
							}
							if stat != nil {
								return &localStatusType{status: stat, logLevel: slog.LevelError}, nil
							}
						}
						return nil, nil
					}()
					if handleErr != nil {
						grpcfed.Logger(ctx).ErrorContext(ctx, "failed to handle error", slog.String("error", handleErr.Error()))
						// If it fails during error handling, return the original error.
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Product_ProductService_GetProduct, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					} else if stat != nil {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Product_ProductService_GetProduct, stat.status.Err()); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, stat.logLevel, grpcfed.LogAttrs(ctx))
						}
					} else {
						if err := s.errorHandler(ctx, BFFService_DependentMethod_Product_ProductService_GetProduct, err); err != nil {
							return nil, grpcfed.NewErrorWithLogAttrs(err, slog.LevelError, grpcfed.LogAttrs(ctx))
						}
					}
				}
				return ret, nil
			},
		})
	}

	if err := def_product_res(ctx); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.BFFService_Bff_ProductDetailVariable.ErrorReason = value.vars.ErrorReason
	req.BFFService_Bff_ProductDetailVariable.ProductRes = value.vars.ProductRes
	req.BFFService_Bff_ProductDetailVariable.ProductViolationType = value.vars.ProductViolationType

	// create a message value to be returned.
	ret := &ProductDetail{}

	// field binding section.
	// (grpc.federation.field).by = "product_res.product"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*backend.Product]{
		Value:      value,
		Expr:       `product_res.product`,
		CacheIndex: 142,
		Setter: func(v *backend.Product) error {
			ret.Product = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "$.item.quantity"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int32]{
		Value:      value,
		Expr:       `$.item.quantity`,
		CacheIndex: 143,
		Setter: func(v int32) error {
			ret.Quantity = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "double($.item.quantity) * $.item.price"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[float64]{
		Value:      value,
		Expr:       `double($.item.quantity) * $.item.price`,
		CacheIndex: 144,
		Setter: func(v float64) error {
			ret.Subtotal = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved bff.ProductDetail", slog.Any("bff.ProductDetail", s.logvalue_Bff_ProductDetail(ret)))
	return ret, nil
}

// resolve_Bff_UserStatistics resolve "bff.UserStatistics" message.
func (s *BFFService) resolve_Bff_UserStatistics(ctx context.Context, req *BFFService_Bff_UserStatisticsArgument) (*UserStatistics, error) {
	ctx, span := s.tracer.Start(ctx, "bff.UserStatistics")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve bff.UserStatistics", slog.Any("message_args", s.logvalue_Bff_UserStatisticsArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.bff.UserStatisticsArgument", req)}

	// create a message value to be returned.
	ret := &UserStatistics{}

	// field binding section.
	// (grpc.federation.field).by = "$.total_orders"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[int32]{
		Value:      value,
		Expr:       `$.total_orders`,
		CacheIndex: 145,
		Setter: func(v int32) error {
			ret.TotalOrders = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "0.0"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[float64]{
		Value:      value,
		Expr:       `0.0`,
		CacheIndex: 146,
		Setter: func(v float64) error {
			ret.TotalSpent = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved bff.UserStatistics", slog.Any("bff.UserStatistics", s.logvalue_Bff_UserStatistics(ret)))
	return ret, nil
}

// cast_Order_OrderErrorReason__to__Bff_OrderErrorReason cast from "order.OrderErrorReason" to "bff.OrderErrorReason".
func (s *BFFService) cast_Order_OrderErrorReason__to__Bff_OrderErrorReason(from backend.OrderErrorReason) (OrderErrorReason, error) {
	var ret OrderErrorReason
	switch from {
	case backend.OrderErrorReason_ORDER_ERROR_REASON_MAINTENANCE:
		ret = OrderErrorReason_ORDER_ERROR_REASON_MAINTENANCE
	case backend.OrderErrorReason_ORDER_ERROR_REASON_UNEXPECTED_ERROR:
		ret = OrderErrorReason_ORDER_ERROR_REASON_UNEXPECTED_ERROR
	default:
		ret = OrderErrorReason_ORDER_ERROR_REASON_UNSPECIFIED
	}
	return ret, nil
}

// cast_Order_OrderFailureCode__to__Bff_OrderViolationType cast from "order.OrderFailureCode" to "bff.OrderViolationType".
func (s *BFFService) cast_Order_OrderFailureCode__to__Bff_OrderViolationType(from backend.OrderFailureCode) (OrderViolationType, error) {
	var ret OrderViolationType
	switch from {
	case backend.OrderFailureCode_ORDER_FAILURE_CODE_ORDER_NOT_FOUND:
		ret = OrderViolationType_ORDER_VIOLATION_TYPE_ORDER_NOT_FOUND
	case backend.OrderFailureCode_ORDER_FAILURE_CODE_ORDER_CANCELLED:
		ret = OrderViolationType_ORDER_VIOLATION_TYPE_ORDER_CANCELLED
	case backend.OrderFailureCode_ORDER_FAILURE_CODE_ORDER_NO_ITEMS:
		ret = OrderViolationType_ORDER_VIOLATION_TYPE_NO_ITEMS
	default:
		ret = OrderViolationType_ORDER_VIOLATION_TYPE_UNSPECIFIED
	}
	return ret, nil
}

// cast_Product_ProductErrorReason__to__Bff_ProductErrorReason cast from "product.ProductErrorReason" to "bff.ProductErrorReason".
func (s *BFFService) cast_Product_ProductErrorReason__to__Bff_ProductErrorReason(from backend.ProductErrorReason) (ProductErrorReason, error) {
	var ret ProductErrorReason
	switch from {
	case backend.ProductErrorReason_PRODUCT_ERROR_REASON_MAINTENANCE:
		ret = ProductErrorReason_PRODUCT_ERROR_REASON_MAINTENANCE
	case backend.ProductErrorReason_PRODUCT_ERROR_REASON_UNEXPECTED_ERROR:
		ret = ProductErrorReason_PRODUCT_ERROR_REASON_UNEXPECTED_ERROR
	default:
		ret = ProductErrorReason_PRODUCT_ERROR_REASON_UNSPECIFIED
	}
	return ret, nil
}

// cast_Product_ProductFailureCode__to__Bff_ProductViolationType cast from "product.ProductFailureCode" to "bff.ProductViolationType".
func (s *BFFService) cast_Product_ProductFailureCode__to__Bff_ProductViolationType(from backend.ProductFailureCode) (ProductViolationType, error) {
	var ret ProductViolationType
	switch from {
	case backend.ProductFailureCode_PRODUCT_FAILURE_CODE_PRODUCT_NOT_FOUND:
		ret = ProductViolationType_PRODUCT_VIOLATION_TYPE_PRODUCT_NOT_FOUND
	case backend.ProductFailureCode_PRODUCT_FAILURE_CODE_PRODUCT_OUT_OF_STOCK:
		ret = ProductViolationType_PRODUCT_VIOLATION_TYPE_PRODUCT_OUT_OF_STOCK
	default:
		ret = ProductViolationType_PRODUCT_VIOLATION_TYPE_UNSPECIFIED
	}
	return ret, nil
}

// cast_User_UserErrorReason__to__Bff_UserErrorReason cast from "user.UserErrorReason" to "bff.UserErrorReason".
func (s *BFFService) cast_User_UserErrorReason__to__Bff_UserErrorReason(from backend.UserErrorReason) (UserErrorReason, error) {
	var ret UserErrorReason
	switch from {
	case backend.UserErrorReason_USER_ERROR_REASON_MAINTENANCE:
		ret = UserErrorReason_USER_ERROR_REASON_MAINTENANCE
	case backend.UserErrorReason_USER_ERROR_REASON_UNEXPECTED_ERROR:
		ret = UserErrorReason_USER_ERROR_REASON_UNEXPECTED_ERROR
	default:
		ret = UserErrorReason_USER_ERROR_REASON_UNSPECIFIED
	}
	return ret, nil
}

// cast_User_UserFailureCode__to__Bff_UserViolationType cast from "user.UserFailureCode" to "bff.UserViolationType".
func (s *BFFService) cast_User_UserFailureCode__to__Bff_UserViolationType(from backend.UserFailureCode) (UserViolationType, error) {
	var ret UserViolationType
	switch from {
	case backend.UserFailureCode_USER_FAILURE_CODE_USER_NOT_FOUND:
		ret = UserViolationType_USER_VIOLATION_TYPE_USER_NOT_FOUND
	case backend.UserFailureCode_USER_FAILURE_CODE_USER_ACCOUNT_SUSPENDED:
		ret = UserViolationType_USER_VIOLATION_TYPE_ACCOUNT_SUSPENDED
	default:
		ret = UserViolationType_USER_VIOLATION_TYPE_UNSPECIFIED
	}
	return ret, nil
}

// cast_int64__to__int32 cast from "int64" to "int32".
func (s *BFFService) cast_int64__to__int32(from int64) (int32, error) {
	ret, err := grpcfed.Int64ToInt32(from)
	if err != nil {
		return ret, err
	}
	return ret, nil
}

func (s *BFFService) logvalue_Bff_GetOrderDetailsResponse(v *GetOrderDetailsResponse) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Any("order", s.logvalue_Order_Order(v.GetOrder())),
		slog.Any("user", s.logvalue_User_User(v.GetUser())),
		slog.Any("product_details", s.logvalue_repeated_Bff_ProductDetail(v.GetProductDetails())),
	)
}

func (s *BFFService) logvalue_Bff_GetOrderDetailsResponseArgument(v *BFFService_Bff_GetOrderDetailsResponseArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("order_id", v.OrderId),
	)
}

func (s *BFFService) logvalue_Bff_GetUserDashboardResponse(v *GetUserDashboardResponse) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Any("user", s.logvalue_User_User(v.GetUser())),
		slog.Any("recent_orders", s.logvalue_repeated_Order_Order(v.GetRecentOrders())),
		slog.Any("recommended_products", s.logvalue_repeated_Product_Product(v.GetRecommendedProducts())),
		slog.Any("statistics", s.logvalue_Bff_UserStatistics(v.GetStatistics())),
	)
}

func (s *BFFService) logvalue_Bff_GetUserDashboardResponseArgument(v *BFFService_Bff_GetUserDashboardResponseArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("user_id", v.UserId),
	)
}

func (s *BFFService) logvalue_Bff_GetUserWithOrdersResponse(v *GetUserWithOrdersResponse) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Any("user", s.logvalue_User_User(v.GetUser())),
		slog.Any("orders", s.logvalue_repeated_Order_Order(v.GetOrders())),
		slog.Int64("total_orders", int64(v.GetTotalOrders())),
	)
}

func (s *BFFService) logvalue_Bff_GetUserWithOrdersResponseArgument(v *BFFService_Bff_GetUserWithOrdersResponseArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("user_id", v.UserId),
	)
}

func (s *BFFService) logvalue_Bff_ProductDetail(v *ProductDetail) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Any("product", s.logvalue_Product_Product(v.GetProduct())),
		slog.Int64("quantity", int64(v.GetQuantity())),
		slog.Float64("subtotal", v.GetSubtotal()),
	)
}

func (s *BFFService) logvalue_Bff_ProductDetailArgument(v *BFFService_Bff_ProductDetailArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Any("item", s.logvalue_Order_OrderItem(v.Item)),
	)
}

func (s *BFFService) logvalue_Bff_UserStatistics(v *UserStatistics) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Int64("total_orders", int64(v.GetTotalOrders())),
		slog.Float64("total_spent", v.GetTotalSpent()),
	)
}

func (s *BFFService) logvalue_Bff_UserStatisticsArgument(v *BFFService_Bff_UserStatisticsArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Int64("total_orders", v.TotalOrders),
		slog.Any("orders", s.logvalue_repeated_Order_Order(v.Orders)),
	)
}

func (s *BFFService) logvalue_Order_CreateOrderRequest(v *backend.CreateOrderRequest) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("user_id", v.GetUserId()),
		slog.Any("items", s.logvalue_repeated_Order_OrderItem(v.GetItems())),
	)
}

func (s *BFFService) logvalue_Order_GetOrderRequest(v *backend.GetOrderRequest) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("order_id", v.GetOrderId()),
	)
}

func (s *BFFService) logvalue_Order_ListOrdersByUserRequest(v *backend.ListOrdersByUserRequest) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("user_id", v.GetUserId()),
		slog.Int64("limit", int64(v.GetLimit())),
		slog.Int64("offset", int64(v.GetOffset())),
	)
}

func (s *BFFService) logvalue_Order_Order(v *backend.Order) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.GetId()),
		slog.String("user_id", v.GetUserId()),
		slog.Any("items", s.logvalue_repeated_Order_OrderItem(v.GetItems())),
		slog.Float64("total_amount", v.GetTotalAmount()),
		slog.String("status", s.logvalue_Order_OrderStatus(v.GetStatus()).String()),
		slog.String("created_at", v.GetCreatedAt()),
		slog.String("updated_at", v.GetUpdatedAt()),
	)
}

func (s *BFFService) logvalue_Order_OrderItem(v *backend.OrderItem) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("product_id", v.GetProductId()),
		slog.Int64("quantity", int64(v.GetQuantity())),
		slog.Float64("price", v.GetPrice()),
	)
}

func (s *BFFService) logvalue_Order_OrderStatus(v backend.OrderStatus) slog.Value {
	switch v {
	case backend.OrderStatus_ORDER_STATUS_UNSPECIFIED:
		return slog.StringValue("ORDER_STATUS_UNSPECIFIED")
	case backend.OrderStatus_ORDER_STATUS_PENDING:
		return slog.StringValue("ORDER_STATUS_PENDING")
	case backend.OrderStatus_ORDER_STATUS_PROCESSING:
		return slog.StringValue("ORDER_STATUS_PROCESSING")
	case backend.OrderStatus_ORDER_STATUS_SHIPPED:
		return slog.StringValue("ORDER_STATUS_SHIPPED")
	case backend.OrderStatus_ORDER_STATUS_DELIVERED:
		return slog.StringValue("ORDER_STATUS_DELIVERED")
	case backend.OrderStatus_ORDER_STATUS_CANCELLED:
		return slog.StringValue("ORDER_STATUS_CANCELLED")
	}
	return slog.StringValue("")
}

func (s *BFFService) logvalue_Product_GetProductRequest(v *backend.GetProductRequest) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("product_id", v.GetProductId()),
	)
}

func (s *BFFService) logvalue_Product_GetProductsByIDsRequest(v *backend.GetProductsByIDsRequest) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Any("product_ids", v.GetProductIds()),
	)
}

func (s *BFFService) logvalue_Product_ListProductsRequest(v *backend.ListProductsRequest) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("category", v.GetCategory()),
		slog.Int64("limit", int64(v.GetLimit())),
		slog.Int64("offset", int64(v.GetOffset())),
	)
}

func (s *BFFService) logvalue_Product_Product(v *backend.Product) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.GetId()),
		slog.String("name", v.GetName()),
		slog.String("description", v.GetDescription()),
		slog.Float64("price", v.GetPrice()),
		slog.String("category", v.GetCategory()),
		slog.Int64("stock", int64(v.GetStock())),
		slog.String("created_at", v.GetCreatedAt()),
	)
}

func (s *BFFService) logvalue_User_GetUserRequest(v *backend.GetUserRequest) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("user_id", v.GetUserId()),
	)
}

func (s *BFFService) logvalue_User_ListUsersRequest(v *backend.ListUsersRequest) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Int64("limit", int64(v.GetLimit())),
		slog.Int64("offset", int64(v.GetOffset())),
	)
}

func (s *BFFService) logvalue_User_User(v *backend.User) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.GetId()),
		slog.String("name", v.GetName()),
		slog.String("email", v.GetEmail()),
		slog.Int64("age", int64(v.GetAge())),
		slog.String("created_at", v.GetCreatedAt()),
	)
}

func (s *BFFService) logvalue_repeated_Bff_ProductDetail(v []*ProductDetail) slog.Value {
	attrs := make([]slog.Attr, 0, len(v))
	for idx, vv := range v {
		attrs = append(attrs, slog.Attr{
			Key:   grpcfed.ToLogAttrKey(idx),
			Value: s.logvalue_Bff_ProductDetail(vv),
		})
	}
	return slog.GroupValue(attrs...)
}

func (s *BFFService) logvalue_repeated_Order_Order(v []*backend.Order) slog.Value {
	attrs := make([]slog.Attr, 0, len(v))
	for idx, vv := range v {
		attrs = append(attrs, slog.Attr{
			Key:   grpcfed.ToLogAttrKey(idx),
			Value: s.logvalue_Order_Order(vv),
		})
	}
	return slog.GroupValue(attrs...)
}

func (s *BFFService) logvalue_repeated_Order_OrderItem(v []*backend.OrderItem) slog.Value {
	attrs := make([]slog.Attr, 0, len(v))
	for idx, vv := range v {
		attrs = append(attrs, slog.Attr{
			Key:   grpcfed.ToLogAttrKey(idx),
			Value: s.logvalue_Order_OrderItem(vv),
		})
	}
	return slog.GroupValue(attrs...)
}

func (s *BFFService) logvalue_repeated_Product_Product(v []*backend.Product) slog.Value {
	attrs := make([]slog.Attr, 0, len(v))
	for idx, vv := range v {
		attrs = append(attrs, slog.Attr{
			Key:   grpcfed.ToLogAttrKey(idx),
			Value: s.logvalue_Product_Product(vv),
		})
	}
	return slog.GroupValue(attrs...)
}
